{"title": "더욱 덜 귀찮게 HTTP 에러를 처리하기 + RFC7807", "content": "## 개요\n\nGo 언어에서 http api를 생성할 때, 가장 귀찮은 건 에러 처리입니다. 대표적으로 이런 코드가 있습니다.\n\n```go\nfunc(w http.ResponseWriter, r *http.Request) {\n    err := doSomething()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        log.Printf(\"error occurred: %v\", err)\n        return\n    }\n    // ...\n}\n```\n\nAPI가 몇개 되지 않는 다면, 이런 식으로 작성해도 딱히 불편한 건 없을 겁니다. 다만, API 수가 늘어나고 내부 로직이 복잡해질 수록 세가지가 거슬리게 됩니다.\n\n1. 적절한 에러 코드 반환\n2. 많은 결과 로그 작성 수\n3. 명확한 에러 메시지 전송\n\n## 본론\n\n### 적절한 에러 코드 반환\n\n물론 1번, 적절한 에러 코드 반환은 제 개인적인 불만 사항이긴 합니다. 숙련된 개발자라면 적절한 코드를 찾아서 매번 잘 찾아 넣을 겁니다만, 저도 그렇고 아직 미숙한 개발자들은 로직이 복잡해지고, 회수가 많아질 수록 적합한 에러 코드를 규칙적으로 쓰는 것에 어려움을 겪을 수 있습니다.\n\n하지만 이는 IDE(혹은 Language Server)의 도움을 받는 인간 개발자에게 최적의 방법으로 보이진 않습니다. 또한 REST API 자체가 에러 코드에 담긴 의미를 최대한 활용하는 만큼, 또 다른 방식을 제안할 수 있을 겁니다. `HttpError`라는 에러(`error`) 인터페이스 구현체를 새로 만들어, `StatusCode`와 `Message`를 저장하게 합니다. 그리고 다음과 같은 헬퍼 함수를 제공합니다.\n\n```go\nerr := httperror.BadRequest(\"wrong format\")\n```\n\n### 많은 결과 로그 작성 수\n\n에러 발생 시 당연히 로그를 남기게 됩니다. API가 호출되고, 요청이 성공했는지, 실패했는지에 대해 로그를 남길 때에 시작부터 모든 예상 종료 지점에 로그를 남기는 건 작성할 코드 수가 많아집니다. 이를 핸들러 자체를 한번 감싸면서, 중앙에서 관리할 수 있게 됩니다.\n\n### 명확한 에러 메시지 전송\n\n이를 위한 문서로 RFC7807이 있습니다. RFC7807은 주로 다음과 같은 요소를 정의하여 사용합니다.\n\n- `type`: 에러 유형을 식별하는 URI. 주로 에러에 대해 설명하는 문서입니다.\n- `title`: 어떤 에러인지에 대한 한줄 설명입니다.\n- `status`: HTTP Status Code와 동일합니다.\n- `detail`: 해당 에러에 대해 사람이 읽을 수 있는 자세한 설명입니다.\n- `instance`: 에러가 발생한 URI입니다.\n- `extensions`: JSON Object 형태로 구성되는 에러를 설명하기 위한 부차적인 요소입니다.\n\n이렇게 중앙화된 라우터를 사용하여 에러를 처리하면, 매번 에러 코드를 확인하고, 적절한 에러 메시지를 작성하는 것에 대한 부담을 줄일 수 있습니다. 또한 RFC7807을 활용하여 구조화된 에러 메시지를 제공함으로써, 클라이언트가 에러를 이해하고 처리하는 데 도움을 줄 수 있습니다.", "author": "snowmerak", "original_url": "https://gosuda.org/blog/posts/handling-http-errors-more-conveniently-+-rfc7807-z862df968", "created_date": "2025-05-19T20:56:37.945722346Z"}
{"title": "Go의 Compile-Time Variable Injection", "content": "이번에 회사 프로젝트 작업을 하면서 .env 없이 컴파일 타임 때 변수를 주입하는 방법이 있나 찾아보았다. 이렇게 하면 `.env`나 여러 콘피그 파일 없이 단일 파일만 있으면 되기 때문에 굉장히 편리할 거라 생각했다.\n\n## 컴파일 타임 변수 주입\n\n사용법은 간단하다.\n\n```go\npackage main\n\nimport \"fmt\"\n\nvar Foo string\n\nfunc main() {\n    fmt.Println(Foo)\n}\n```\n\n위와 같은 코드가 있다고 하면, 빌드 시 다음과 같이 주입할 수 있다.\n\n```bash\ngo build -ldflags=\"-X 'main.Foo=bar'\"\n```\n\nldflag로 인자를 넘겨주면 빌드 시 컴파일 타임에 `Foo` 변수에 `bar` 값이 주입된다. 간단하다.\n\n만약 프로젝트에서 같은 이름의 패키지나 변수가 여러 곳에 있다면 **패키지 경로를 명시하면** 된다.", "author": "wHoIsDReAmer", "original_url": "https://gosuda.org/blog/posts/compile-time-variable-injection-of-go-z5420556c", "created_date": "2025-06-01T15:56:46.352281271Z"}
{"title": "Go 언어 동시성 프로그래밍 입문", "content": "Go 언어의 가장 큰 특징 중 하나는 동시성(concurrency) 프로그래밍을 위한 강력한 기능들을 제공한다는 것입니다. 이 글에서는 Go의 동시성 프로그래밍에 대한 기본적인 개념과 사용법을 소개합니다.\n\n## 동시성 관리\n\n### channel\n\n채널은 고루틴 간에 데이터를 주고받을 수 있는 통신 수단입니다. 채널을 사용하면 고루틴 간의 안전한 데이터 교환이 가능합니다.\n\n#### select\n\n`select` 문을 사용하면 여러 채널에서 동시에 데이터를 받을 수 있습니다. 여러 채널 중 하나라도 준비되면 해당 케이스가 실행됩니다.\n\n```go\nselect {\ncase v := <-ch1:\n    fmt.Println(v)\ncase v := <-ch2:\n    fmt.Println(v)\ncase v := <-ch3:\n    fmt.Println(v)\n}\n```\n\n위 코드는 주기적으로 1, 2, 3을 전달하는 3개의 채널을 만들고, `select`를 사용하여 채널에서 값을 받아 출력하는 코드입니다. 이러한 방식으로 `select`를 사용하면, 여러 채널에서 동시에 데이터를 전달 받으면서, 채널에서 값을 받는 대로 처리할 수 있습니다.\n\n#### for range\n\n채널을 사용하여 동기식 코드를 비동기식 코드로 변경할 수 있습니다. 이러한 방식으로 `channel`을 사용하면, 동기식 코드를 비동기식 코드로 쉽게 변경하고, `join` 지점을 설정할 수 있습니다.", "author": "snowmerak", "original_url": "https://gosuda.org/blog/posts/concurrency-for-starter", "created_date": "2024-01-01T00:00:00Z"}
{"title": "Go에서 Tk로 Hello World 만들기", "content": "최근에 Go 언어에서도 Tcl/Tk를 사용할 수 있도록 CGo-Free, Cross Platform Tk 라이브러리가 개발되었습니다. 오늘은 그 기초적인 사용법을 살펴보겠습니다.\n\n## Hello, Tk 만들기\n\n## SVG 파일 처리하기\n\n다음은 SVG 파일을 라벨 위젯에 표시하는 예제입니다.\n\n```go\npackage main\n\nimport . \"modernc.org/tk9.0\"\n\n// https://en.wikipedia.org/wiki/SVG\nconst svg = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"391\" height=\"391\" viewBox=\"-70.5 -70.5 391 391\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n<rect fill=\"#fff\" stroke=\"#000\" x=\"-70\" y=\"-70\" width=\"390\" height=\"390\"/>\n<g opacity=\"0.8\">\n```\n\n이 라이브러리에서 SVG를 처리하는 방법은 다음과 같습니다:\n\n1. SVG 파일의 내용을 문자열로 읽어들입니다(또는 위 예시처럼 직접 포함시킵니다).\n2. 이 내용을 Data 함수에 전달하여 옵션이 포함된 문자열로 변환합니다(-data 옵션).\n3. 변환된 바이트값은 NewPhoto 함수로 전달되어 Tcl/Tk 이미지를 표현하는 Img 구조체 포인터를 반환합니다.\n4. Image 함수를 통과하면서 Img 구조체 포인터는 -Image 옵션이 추가된 문자열로 변환됩니다.\n5. 구조체 RAW 값을 담은 문자열로 변환하는 이유는 Label 위젯 생성을 위해서입니다.\n\n## PNG 파일 처리하기\n\n```go\npackage main\n\nimport _ \"embed\"\nimport . \"modernc.org/tk9.0\"\n\n//go:embed gopher.png\nvar gopher []byte\n\nfunc main() {\n    Pack(Label(Image(NewPhoto(Data(gopher)))),\n        TExit(),\n        Padx(\"1m\"), Pady(\"2m\"), Ipadx(\"1m\"), Ipady(\"1m\"))\n    App.Center().Wait()\n}\n```\n\nPNG 파일 처리 과정은 다음과 같습니다:\n\n1. 임베딩된 gopher.png를 옵션이 포함된 문자열 타입으로 변환합니다.\n2. NewPhoto 함수를 통해 \\*Img 타입으로 변환합니다.\n3. Image 함수를 거쳐 RAW 문자열로 변환된 후, 라벨 위젯으로 생성됩니다.\n\n## 정리\n\n이번 글에서는 Go 언어의 Tcl/Tk 라이브러리를 활용하여 다음 내용을 다뤘습니다:\n\n1. GUI 애플리케이션 기본 구조\n2. SVG, PNG, ICO 등 다양한 이미지 포맷 처리\n3. 위젯 패킹과 레이아웃 관리\n4. 이미지 데이터 처리 구조\n5. 단축키 바인딩과 위젯 커맨드\n\nGo 언어와 Tcl/Tk를 함께 사용하면 간단하면서도 실용적인 GUI 프로그램을 만들 수 있습니다.", "author": "Yunjin Lee", "original_url": "https://gosuda.org/blog/posts/go-tk-helloworld", "created_date": "2024-11-19T11:51:05.279238471Z"}
{"title": "Go에서 Tk로 파일 목록이 추가된 이미지 뷰어 만들기", "content": "지난 게시물에서는 CGo-Free Tcl/Tk 라이브러리에 대해 간단하게 살펴 봤습니다. 이번 시간에는 지난 번의 예제를 응용하여 이미지 뷰어를 만들어 보도록 하겠습니다.\n\n## 이미지 뷰어 계획\n\n1. 지난 시간의 이미지 표시기는 이미지 삭제 기능이 없어 여러 이미지들을 불러올 수록 창의 크기가 모자랐습니다. 사용하지 않는 라벨을 삭제해 줍시다.\n2. 이미지 표시기에 여러 이미지를 목록화할 것이라면 리스트를 만들어 줍시다.\n3. 한 번에 여러 이미지를 불러오는 것이 좋습니다.\n4. 보지 않을 이미지를 목록에서 빼는 것도 구현해 줍니다.\n5. 다중 이미지 중 특정 이미지를 선택해서 보는 기능을 만들어 줍시다.\n\n## 수정된 Tcl/Tk 9.0 라이브러리\n\n기존 라이브러리에는 Listbox 구현이 미흡해서 이미지 목록을 보여주기 힘듭니다. 수정된 라이브러리를 다운로드해 줍시다.\n\n```bash\ngit clone https://github.com/yoonjin67/tk9.0\n```\n\n### 리스트: 삽입/삭제\n\n먼저 Tcl 스크립팅을 위해 공식 매뉴얼에서 listbox에 사용 가능한 명령어 중 insert를 살펴 봅시다.\n\ninsert 명령어의 설명 페이지를 보면, insert는 특정 인덱스에 나열된 항목들을 삽입합니다. 그렇다면 이를 구현하기 위해서\n\n```go\nfunc (l *ListboxWidget) AddItem(index int, items string) {\n\tevalErr(fmt.Sprintf(\"%s insert %d %s\", l.fpath, index, items))\n}\n```\n\n와 같은 코드를 작성할 수 있습니다.\n\n### 리스트: 선택된 항목 가져오기\n\n이제 Listbox에서 선택된 항목들을 가지고 온 후 확인해 보겠습니다.\n\n```go\npackage main\n\nimport . \"modernc.org/tk9.0\"\n\nfunc main() {\n    l := Listbox()\n    l.SelectMode(\"multiple\")\n    l.AddItem(0, \"item1 item2 item3\")\n    btn := TButton(Txt(\"Print Selected\"), Command( func() {\n        sel := l.Selected()\n        for _, i := range sel {\n            println(l.GetOne(i))\n        }\n    }))\n\n    Pack(TExit(), l, btn)\n    App.Wait()\n}\n```\n\nSelected 메서드는 현재 Listbox에서 선택된 모든 항목들의 인덱스를 가져옵니다. GetOne 메서드는 해당 인덱스에 해당하는 항목의 값을 가져옵니다.\n\n## 정리\n\n이번 글에서는 Go 언어의 Tcl/Tk 라이브러리의 명령 호출이 어떤 식으로 동작하는지 알아보고, 리스트박스가 추가된 이미지 뷰어를 만들어 보았습니다.\n\n1. Tcl/Tk 라이브러리의 명령 호출 방식\n2. 리스트박스 사용 방법\n3. 리스트박스 위젯의 속성 변경\n4. 이미지 뷰어 작성", "author": "Yunjin Lee", "original_url": "https://gosuda.org/blog/posts/creating-a-image-viewer-with-tk-in-go-z279238471Z", "created_date": "2024-11-19T11:51:05.279238471Z"}
{"title": "Go 그리고 OpenAPI 생태계", "content": "Go 언어로 Production Backend 서버를 개발하다 보면 거의 대부분의 개발자들이 가장 처음으로 만나는 난제 중 하나는 다음과 같습니다.\n\n> API 문서화, 어떻게 하지...?\n\n이에 대하여 조금만 찾아보면 OpenAPI 스펙에 맞는 문서를 작성하는 것이 이롭다는 사실을 깨닫게 되고, 자연스럽게 OpenAPI와 연동되는 라이브러리를 찾게 됩니다. 하지만 이러한 결정을 세워도 그 다음 문제가 존재합니다.\n\n> OpenAPI 관련 라이브러리 많은데.. 뭐 써야하지...?\n\n### OpenAPI 를 대하는 라이브러리들의 전략\n\n이미 알고계신 부분이겠지만, OpenAPI 는 REST API를 명확하게 정의하고 문서화하기 위한 스펙입니다. API의 엔드포인트, 요청, 응답 형식 등을 YAML 또는 JSON 형식으로 정의하여 개발자들 뿐만 아니라 프론트단, 백엔드단 코드 생성을 자동화하여 무의미한 반복을 줄여주고 소소한 휴먼에러들을 줄여주는데 큰 도움을 줍니다.\n\n이러한 OpenAPI 를 프로젝트와 자연스럽게 결합시키기 위해 Go 생태계의 라이브러리들은 크게 다음 세가지 전략을 취합니다.\n\n#### 1. Go 주석을 OpenAPI 스펙 문서로 조합\n\nOpenAPI 에 맞춰서 API 를 개발할때 까다로운점 중 하나는 실제 문서와 해당 문서를 구현한 코드가 별도의 파일로 전혀 다른위치에 존재하다보니, 코드를 업데이트 했는데 문서를 업데이트 안했던가 문서는 업데이트 했는데 코드를 업데이트 하지 못하는 상황이 생각보다 잦다는 것입니다.\n\nGo 주석의 형태로 API 문서를 작성하면 이러한 문제를 어느 정도 해소할 수 있습니다. 코드와 문서가 한 곳에 모여 있기 때문에, 코드를 수정하면서 주석도 함께 업데이트할 수 있습니다.\n\n대표적인 프로젝트로는 Swag가 있습니다. Swag는 Go 코드의 주석을 파싱하여 OpenAPI 2 형식의 문서를 생성해 줍니다.\n\n```go\n// @Summary 유저 생성\n// @Description 새로운 유저를 생성합니다.\n// @Tags Users\n// @Accept json\n// @Produce json\n// @Param user body models.User true \"유저 정보\"\n// @Success 200 {object} models.User\n// @Failure 400 {object} models.ErrorResponse\n// @Router /users [post]\nfunc CreateUser(c *gin.Context) {\n    // ...\n}\n```\n\n**장점:**\n- 주석이 코드와 함께 있기 때문에 **실제 코드와 문서의 형상이 달라질 가능성이 줄어듭니다.**\n- 별도의 도구나 복잡한 설정 없이 주석만으로 **간편하고 자유롭게 문서화**를 할 수 있습니다.\n- 주석이 실제 API 로직에 영향을 주진 않기때문에, **문서로 공개하기 부담스러운 임시 기능을 추가**하기 좋습니다.\n\n**단점:**\n- 주석의 라인수가 많아지면서 단일 코드 파일에 대한 **가독성이 떨어질 수 있습니다.**\n- **주석의 형태**로 모든 API 스펙을 **표현하기 어려울 수 있습니다.**\n- 문서가 코드를 강제하는것은 아니기때문에 OpenAPI **문서와 실제 로직이 일치한다는 보장을 할 수 없습니다.**\n\n## 2. OpenAPI 스펙의 문서로 Go 코드를 생성\n\n이 방식을 채택하는 대표적인 프로젝트로는 oapi-codegen 과 OpenAPI Generator 가 존재합니다. 사용법은 간단합니다.\n\n1. OpenAPI 스펙에 맞게 yaml 혹은 json 문서를 작성하고\n2. CLI 를 실행하면\n3. 그에 대응되는 Go stub 코드가 생성됩니다.\n4. 이제 이 stub 이 사용할 수 있도록 개별 API 에 대한 세부 로직만 직접 구현하면 됩니다.\n\n**장점:**\n- **스펙이 먼저 나오고 개발이 진행**되기 떄문에 여러 팀에서 협업하는경우 **업무를 병렬적으로 진행**하기 유리합니다.\n- **반복성 노가다로 작업**하던 부분에 대한 코드가 **자동으로 생성**되기 때문에, **업무 효율이 상승**하면서도 **디버깅에 여전히 유리**합니다.\n- **문서와 코드의 형상이 항상 일치**하다는것을 보장하기 쉽습니다.\n\n**단점:**\n- OpenAPI 스펙 자체에 무지한 상태일경우 **초기 러닝커브가 다소 존재**합니다.\n- API 를 핸들링하는 코드의 형상이 프로젝트에 의해서 자동으로 생성되기 떄문에 **커스터마이징이 필요한경우 대응하기 어려울 수 있습니다.**\n\n## 3. Go 코드로 OpenAPI 스펙 문서를 생성\n\n수십, 수백명의 사람들이 같은 서버에대해서 개발을 진행하다보면 필연적으로 발생하는 이슈가 개별 API 별로 통일성이 깨질 수 있다는 것입니다. 이러한 기법을 사용하는 대표적인 프로젝트가 Kubernetes 이며 (별도 라이브러리 없이 자체적으로 구축), go-restful, goa 등의 프로젝트를 사용해서 사용해볼수도 있습니다.\n\n```go\nvar _ = Service(\"user\", func() {\n    Method(\"create\", func() {\n        Payload(UserPayload)\n        Result(User)\n        HTTP(func() {\n            POST(\"/users\")\n            Response(StatusOK)\n        })\n    })\n})\n```\n\nGo 언어로 Domain-specific language (DSL) 를 정의하여 모든 API 가 일관적인 통일성을 가질 수 있도록 강제할 수 있습니다.\n\n위와같이 컴파일 가능한 Go 코드를 작성하면 `POST /users` API 에 대한 구현과 문서에 대한 정의가 동시에 완료되는 강점을 얻을 수 있습니다.\n\n**장점:**\n- 코드로부터 모든게 나오기때문에 **프로젝트 전체에 대한 API 일관성을 가지고가기가 쉽습니다**.\n- Go 의 강타입 시스템을 활용하여, OpenAPI3 의 모든 기능을 활용했을때보다 **더 정확하고 논란이 없는 스펙**을 얻을 수 있습니다.\n\n현재 2024년 10월을 기준으로 글을 작성하긴 했지만 Go와 OpenAPI 생태계는 지속적으로 발전하고 있으므로, 이 글을 읽는 시점간의 간격을 고려하여 각 라이브러리들 및 프로젝트들의 근황과 그들의 변경된 장단점도 지속적으로 팔로업하시길 바랍니다.\n\n행복한 Go 라이프 되세요~ 😘", "author": "iwanhae", "original_url": "https://gosuda.org/blog/posts/go-and-the-openapi-ecosystem-zd5a8e472", "created_date": "2024-10-18T06:07:43.092628696Z"}
{"title": "dotnet aspire에서 Go 서버와 함께 사용하기", "content": "## 프로젝트 구성\n\n### dotnet aspire 프로젝트 생성\n\n그럼 세팅을 위한 간단한 코드만 존재하는 aspire-apphost 프로젝트가 생성됩니다.\n\n### Go 언어 에코 서버 생성\n\n그럼 간단한 Go 언어 서버를 추가해보겠습니다. 일단 솔루션 폴더에서 `go work init`을 통해 워크스페이스를 생성합니다. 닷넷 개발자에겐 Go 워크스페이스는 솔루션과 유사한 거라 보시면 됩니다.\n\n그리고 EchoServer라는 폴더를 만들고, 안으로 이동한 후 `go mod init EchoServer`를 실행합니다. 이 명령어를 통해 Go 모듈을 생성합니다. 모듈은 닷넷 개발자에게 프로젝트와 유사한 것으로 인지하시면 됩니다.\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\taddr := os.Getenv(\"PORT\")\n\tlog.Printf(\"Server started on %s\", addr)\n\n\thttp.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) {\n\t\tname := request.URL.Query().Get(\"name\")\n\t\twriter.Write([]byte(\"Hello, \" + name))\n\t})\n\n\thttp.ListenAndServe(\":\"+addr, nil)\n}\n```\n\n이 서버는 Aspire AppHost가 실행될 때, listening을 해야할 `PORT` 환경 변수를 주입해주면, 해당 포트를 읽어서 서버를 실행합니다. 간단하게 `name` 쿼리를 받아서 `Hello, {name}`을 반환하는 서버입니다.\n\n이제 이 서버를 dotnet aspire에 추가해보겠습니다.\n\n## 프로젝트 확장\n\n### 수평 확장은 그럼 어떻게 해?\n\n### YARP로 reverse proxy 구성\n\n### Reverse proxy 수정\n\n### 확장 아이디어\n\n8개로 늘어간 echo server 인스턴스에 대해 목적지 설정을 추가합니다. 이제 reverse proxy는 늘어간 echo server들에 대한 목적지 정보를 가지고, 요청을 전달해줄 수 있게 되었습니다. 기존의 `http://localhost:3000/?name=world`로 접속해보시면, 여전히 `Hello, world`가 출력되는 걸 확인하실 수 있을 겁니다.\n\n## 마치며\n\n이 글에서는 dotnet aspire에 Go 서버를 추가하고, reverse proxy를 통해 요청을 전달하는 과정을 설명했습니다. 다만 확장에 관해서는 아직 모두 작성하진 않았고, 환경 변수를 통해 좀 더 programmatic하게 구현할 수 있는 예제를 별도 레포에 작성해놓았습니다. 자세한 프로젝트 구성과 코드는 snowmerak/AspireStartPack을 참고해주세요.\n\n저는 개인적으로 dotnet aspire가 docker compose의 대안으로써, 그리고 클라우드 배포 툴로써 자신만의 롤을 수행할 수 있다고 기대합니다. 이미 docker compose나 k8s manifest를 생성하는 제너레이터가 존재하여, 일반 개발자가 인프라 도구에 대한 접근성이 더 좋아지지 않았나 생각합니다.", "author": "snowmerak", "original_url": "https://gosuda.org/blog/posts/go-on-dotnet-aspire", "created_date": "2024-01-01T00:00:00Z"}
{"title": "Cilium PR #37747 분석", "content": "## 배경지식\n\n### NAT\n\n스마트폰 (a.a.a.a:50000) ==> 공유기 (b.b.b.b) ==> 웹 서버 (c.c.c.c:80)\n\n공유기는 스마트폰의 요청을 받으면 다음과 같은 TCP Packet 을 보게될것입니다.\n\n```\n# 공유기가 받은 TCP 패킷, 스마트폰 => 공유기\n| src ip  | src port | dst ip  | dst port |\n-------------------------------------------\n| a.a.a.a | 50000    | c.c.c.c | 80       |\n```\n\n이 패킷을 그대로 웹 서버(`c.c.c.c`)로 보냈다가는 사설 IP 주소를 가지는 스마트폰 (`a.a.a.a`) 에게 응답이 돌아오지 않을것이므로, 공유기는 먼저 현재 통신에 관여하지 않는 임의의 port (예: 60000) 를 찾아내고 내부 NAT 테이블에 기록해둡니다.\n\n```\n# 공유기 내부 NAT 테이블\n| local ip  | local port | global ip  | global port |\n-----------------------------------------------------\n| a.a.a.a   | 50000      | b.b.b.b    | 60000       |\n```\n\n공유기는 NAT 테이블에 새 항목을 기록한 후, 스마트폰에서 받은 TCP 패킷의 출발지 IP 주소와 포트 번호를 자신의 공인 IP 주소(`b.b.b.b`)와 새로 할당한 포트 번호(60000)로 변경하여 웹 서버로 전송합니다.\n\n```\n# 공유기가 보낸 TCP 패킷, 공유기 => 웹 서버\n# SNAT 수행\n| src ip  | src port | dst ip  | dst port |\n-------------------------------------------\n| b.b.b.b | 60000    | c.c.c.c | 80       |\n```\n\n## 후기 - 2\n\n이 이야기는 Go 언어를 전문적으로 다루는 Gosuda 와는 사실 직접적으로 어울리는 주제는 아니긴 합니다. 하지만 Go 언어와 클라우드 생태계는 밀접한 관련이 있고 Cilium 의 기여자들은 Go 언어에 어느정도 소양이 있는 만큼 개인 블로그에 올릴 수 있는 내용을 Gosuda 로 한번 가져와 봤습니다.\n\n관리자 중 한명 (저 자신) 의 허락이 있었기 때문에 아마 괜찮을 것이라고 생각합니다. 안괜찮다고 생각하신다면 언제 삭제될지 모르니 얼른 PDF 로 저장해두시길 바랍니다. ;)", "author": "iwanhae", "original_url": "https://gosuda.org/blog/posts/cilium-pr-37747", "created_date": "2024-01-01T00:00:00Z"}
{"title": "MCP와 C# 그리고 Go", "content": "## Go로 된 MCP 호스트\n\n### mark3lab's mcphost\n\nGo에는 mark3lab이란 조직에서 개발 중인 mcphost가 있습니다.\n\n사용법은 매우 간단합니다.\n\n```sh\ngo install github.com/mark3labs/mcphost@latest\n```\n\n설치 후, `$HOME/.mcp.json` 파일을 만들어서 다음과 같이 작성합니다.\n\n```json\n{\n  \"mcpServers\": {\n    \"sqlite\": {\n      \"command\": \"uvx\",\n      \"args\": [\n        \"mcp-server-sqlite\",\n        \"--db-path\",\n        \"/tmp/foo.db\"\n      ]\n    },\n    \"filesystem\": {\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"@modelcontextprotocol/server-filesystem\",\n        \"/tmp\"\n      ]\n    }\n  }\n}\n```\n\n### mcphost 포크\n\n이미 확인했다시피 `mcphost`에는 MCP를 활용해서 메타데이터를 추출하고, 함수를 호출하는 기능이 포함되어 있습니다. 그러므로 llm을 호출하는 부분, mcp 서버를 다루는 부분, 메시지 히스토리를 관리하는 부분이 필요합니다.\n\n해당하는 부분을 가져온 것이 다음 패키지의 `Runner`입니다.\n\n```go\npackage runner\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\t\"time\"\n\n\tmcpclient \"github.com/mark3labs/mcp-go/client\"\n\t\"github.com/mark3labs/mcp-go/mcp\"\n\n\t\"github.com/mark3labs/mcphost/pkg/history\"\n\t\"github.com/mark3labs/mcphost/pkg/llm\"\n)\n\ntype Runner struct {\n\tprovider   llm.Provider\n```\n\n메인 요리는 `Run` 메서드입니다.\n\n```go\nfunc (r *Runner) Run(ctx context.Context, prompt string) (string, error) {\n\tif len(prompt) != 0 {\n\t\tr.messages = append(r.messages, history.HistoryMessage{\n\t\t\tRole: \"user\",\n\t\t\tContent: []history.ContentBlock{{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: prompt,\n\t\t\t}},\n\t\t})\n\t}\n\n\tllmMessages := make([]llm.Message, len(r.messages))\n```\n\n코드 자체는 해당 파일의 일부 코드를 짜집기 하였습니다.\n\n내용은 대략 다음과 같습니다.\n\n1. 프롬프트와 함께 툴 목록을 전송하여 실행 여부, 혹은 응답 생성을 요청합니다.\n2. 응답이 생성되면 재귀를 멈추고 반환합니다.\n3. LLM이 툴 실행 요청을 남긴다면, 호스트에서는 MCP Server를 호출합니다.\n4. 응답을 히스토리에 추가해서 다시 1번으로 돌아갑니다.\n\n## 끝으로\n\n> 벌써 끝?\n\n사실 할 말이 그렇게 많진 않습니다. 대략적으로 MCP Server가 어떻게 동작되는 지에 대한 이해를 도와 드리기 위해 작성된 글입니다. 이 글이 여러분들에게 자그맣게나마 MCP host의 동작을 이해함에 도움이 되었길 바랍니다.", "author": "snowmerak", "original_url": "https://gosuda.org/blog/posts/mcp_with_csharp", "created_date": "2024-01-01T00:00:00Z"}